#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        Festo.py
#
#  Project :     
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      maxim.stassevich$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["Festo", "FestoClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(Festo.additionnal_import) ENABLED START -----#
import threading
import time
import spidev
from scipy import interpolate
import numpy as np


class readWriteFesto(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.running = True
        self.attributeAllowed = True
        self.fault = False
        self.flow1 = None
        self.flow2 = None
        self.vref = 3.3 
        self.resolution_adc = 2**10
        self.resolution_dac = 2**12
        self.spi_max_speed = 1000000
        self.CE_adc = 1
        self.CE_dac = 0
        self.spi_adc = spidev.SpiDev()
        self.spi_dac = spidev.SpiDev()
        self.spi_adc.open(0,self.CE_adc)
        self.spi_dac.open(0,self.CE_dac)
        self.spi_adc.max_speed_hz = self.spi_max_speed
        self.spi_dac.max_speed_hz = self.spi_max_speed
        print "Starting thread"
        
    def run(self):
        while self.running:
            try:
                if self.attributeAllowed:
                    self.flow1 = self.read_mcp3002(0)
                    self.flow1 *= 2
                if self.attributeAllowed:
                    self.flow2 = self.read_mcp3002(1)
                self.fault = False                
            except:                
                self.fault = True
                time.sleep(0.7)
        print "Thread exited"
        
    def stop(self):
        print "Exiting thread.."
        self.running = False
        #self.wait()
    
    def read_mcp3002(self, channel):
        if channel == 0:
            cmd = 0b01100000
        else:
            cmd = 0b01110000
        spi_data = self.spi_adc.xfer2([cmd,0])
        adc_data = ((spi_data[0] & 3) << 8) + spi_data[1]
        voltage = (adc_data * self.vref * 1.0) / self.resolution_adc
        #x = np.arange(0, 3.24, 0.01)
        #y = np.arange(0, 10, 0.01)
        #f = interpolate.interp1d(x, y)
        #flow = f(x)
        f = interpolate.interp1d([0,3.24324324324],[0,10])
        flow = f(voltage)
        return flow
    
    def setOutput(self, val):
        if val > 10 or val < 0:
            return
        #oldRange = (10 - 0)  
        #newRange = (4095 - 0)  
        #newValue = (((val - 0) * newRange) / oldRange) + 0
        f = interpolate.interp1d([0,10],[0,4095])
        newValue = int(f(val))
        self.attributeAllowed = False
        time.sleep(0.1)
        lowByte = newValue & 0b11111111
        highByte = newValue >> 8 & 0b11111111
        highByte = highByte | 0b00110000
        self.spi_dac.xfer2([highByte, lowByte])
        self.attributeAllowed = True
            
    def getData(self):
        return self.fault, self.flow1, self.flow2





#----- PROTECTED REGION END -----#	//	Festo.additionnal_import

# Device States Description
# ON : 
# OFF : 


class Festo (PyTango.Device_4Impl):
    """Class to control proportional flow control valve from Festo"""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(Festo.global_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Festo.global_variables

    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.debug_stream("In __init__()")
        Festo.init_device(self)
        #----- PROTECTED REGION ID(Festo.__init__) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(Festo.delete_device) ENABLED START -----#
        self.festo.stop()
        #----- PROTECTED REGION END -----#	//	Festo.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_actual_value1_read = 0.0
        self.attr_actual_value2_read = 0.0
        #----- PROTECTED REGION ID(Festo.init_device) ENABLED START -----#
        self.set_state(PyTango.DevState.ON)
        self.set_status("Device is in ON state")
        self.festo = readWriteFesto()
        self.festo.start()
        #----- PROTECTED REGION END -----#	//	Festo.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(Festo.always_executed_hook) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.always_executed_hook

    # -------------------------------------------------------------------------
    #    Festo read/write attribute methods
    # -------------------------------------------------------------------------
    
    def read_actual_value1(self, attr):
        self.debug_stream("In read_actual_value1()")
        #----- PROTECTED REGION ID(Festo.actual_value1_read) ENABLED START -----#
        attr.set_value(self.attr_actual_value1_read)
        
        #----- PROTECTED REGION END -----#	//	Festo.actual_value1_read
        
    def is_actual_value1_allowed(self, attr):
        self.debug_stream("In is_actual_value1_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Festo.is_actual_value1_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.is_actual_value1_allowed
        return state_ok
        
    def read_actual_value2(self, attr):
        self.debug_stream("In read_actual_value2()")
        #----- PROTECTED REGION ID(Festo.actual_value2_read) ENABLED START -----#
        attr.set_value(self.attr_actual_value2_read)
        
        #----- PROTECTED REGION END -----#	//	Festo.actual_value2_read
        
    def is_actual_value2_allowed(self, attr):
        self.debug_stream("In is_actual_value2_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF])
        else:
            state_ok = not(self.get_state() in [])
        #----- PROTECTED REGION ID(Festo.is_actual_value2_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.is_actual_value2_allowed
        return state_ok
        
    def write_set_flow(self, attr):
        self.debug_stream("In write_set_flow()")
        data = attr.get_write_value()
        #----- PROTECTED REGION ID(Festo.set_flow_write) ENABLED START -----#
        self.festo.setOutput(data)
        #----- PROTECTED REGION END -----#	//	Festo.set_flow_write
        
    def is_set_flow_allowed(self, attr):
        self.debug_stream("In is_set_flow_allowed()")
        if attr==PyTango.AttReqType.READ_REQ:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF])
        else:
            state_ok = not(self.get_state() in [PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(Festo.is_set_flow_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.is_set_flow_allowed
        return state_ok
        
    
    
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(Festo.read_attr_hardware) ENABLED START -----#
        fault, self.attr_actual_value1_read, self.attr_actual_value2_read = self.festo.getData()
        if fault == True:
            if self.get_state() != PyTango.DevState.OFF:
                self.set_state(PyTango.DevState.OFF)
                self.set_status("Device is in OFF state")
        else:
            if self.get_state() != PyTango.DevState.ON:
                self.set_state(PyTango.DevState.ON)
                self.set_status("Device is in ON state")
        
        #----- PROTECTED REGION END -----#	//	Festo.read_attr_hardware


    # -------------------------------------------------------------------------
    #    Festo command methods
    # -------------------------------------------------------------------------
    
    def set_value(self, argin):
        """ Sets flow
        :param argin: 
        :type argin: PyTango.DevShort
        """
        self.debug_stream("In set_value()")
        #----- PROTECTED REGION ID(Festo.set_value) ENABLED START -----#
        #print argin
        self.festo.setOutput(argin)
        #----- PROTECTED REGION END -----#	//	Festo.set_value
        
    def is_set_value_allowed(self):
        self.debug_stream("In is_set_value_allowed()")
        state_ok = not(self.get_state() in [PyTango.DevState.OFF])
        #----- PROTECTED REGION ID(Festo.is_set_value_allowed) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.is_set_value_allowed
        return state_ok
        

    #----- PROTECTED REGION ID(Festo.programmer_methods) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Festo.programmer_methods

class FestoClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(Festo.global_class_variables) ENABLED START -----#
    
    #----- PROTECTED REGION END -----#	//	Festo.global_class_variables


    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        }


    #    Command definitions
    cmd_list = {
        'set_value':
            [[PyTango.DevShort, "none"],
            [PyTango.DevVoid, "none"]],
        }


    #    Attribute definitions
    attr_list = {
        'actual_value1':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Flow1 (actual value)",
                'unit': "l/min",
            } ],
        'actual_value2':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'label': "Flow2 (actual value)",
                'unit': "l/min",
            } ],
        'set_flow':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.WRITE],
            {
                'label': "set Flow",
                'unit': "l/min",
            } ],
        }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(FestoClass, Festo, 'Festo')
        #----- PROTECTED REGION ID(Festo.add_classes) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#	//	Festo.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)

if __name__ == '__main__':
    main()
